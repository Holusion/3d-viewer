//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.18444
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
namespace AssemblyCSharp
{
	public class Smoother {
		private LimitedQueue<Vector3> movement;
		public Smoother (){
			init (500);
		}
		public Smoother (float coef){
			init (coef);
		}
		private void init (float coef){
			movement = new LimitedQueue<Vector3>(25);
			movement.Enqueue(Vector3.zero);
			movement.Enqueue(Vector3.zero);
		}
		public Vector3 Movement {
			get {
				return average ();
			}
		}


		/**
		 * Push with a default coefficient of .5 (out of 1).
		 **/
		public void Push (Vector3 val){
			Push (val, 0.5f);
		}
		/** 
		 * Coef is a float between 0 and 1
		 **/
		public void Push(Vector3 val,float coefficient){
			Vector3 [] array = this.movement.ToArray();

			this.movement.Enqueue(smooth(val,array[array.Length-1],coefficient));
		}


		/***********************************************************
		 * UTILITIES
		 * ********************************************************/
		private Vector3 average(){
			Vector3 ret = new Vector3(0,0,0);
			float total = 0;
			int count = movement.Count;
			foreach(Vector3 val in movement.ToArray()){
				float coef = (float) Math.Exp(1-(count*0.2+1));
				count--;
				ret = ret+val*coef;
				total +=coef;
			}
			ret = ret/total;
			
			return ret; 
		}
		/**
		 * Smooth vector val by averaging it with vector prev according to coefficient
		 */
		private Vector3 smooth(Vector3 val,Vector3 prev,float coef){
			Vector3 ret = new Vector3(smooth (val.x,prev.x,coef),smooth (val.y,prev.y,coef),smooth (val.z,prev.z,coef));
			return ret;
		}
		/**
		 * average x with u according to coef.
		 */
		private float smooth(float x, float u,float coef){
			/*
			float s = this.smoothCoef;
			float ratio  = (float)(2.5*s*(1 / (s * Math.Sqrt(2*Math.PI) ) ) * Math.Exp( - Math.Pow( x- u, 2) / (2*s*s) ));
			//Debug.Log(ratio);
			return (x*ratio + u*(1-ratio));
			//*/
			//*
			return (x*coef + u*(1f-coef));
			//*/
		}

		private Vector3 trim(Vector3 val){
			float trimVal = 7f;
			float aX = Math.Abs(val.x);
			float aY = Math.Abs(val.y);
			float aZ = Math.Abs(val.z);
			float total = aX+aY+aZ;
			if(aX * trimVal < total){ val.x = 0;}
			if(aY *  trimVal < total){ val.y = 0;}
			if(aZ * trimVal < total){ val.z = 0;}
			return val;
		}

		private Vector3 limit (Vector3 val){
			return new Vector3(Math.Sign(val.x)*Math.Min(150,Math.Abs(val.x)),Math.Sign(val.y)*Math.Min(150,Math.Abs(val.y)),Math.Sign(val.z)*Math.Min(150,Math.Abs(val.z)));
		}
	}
}

