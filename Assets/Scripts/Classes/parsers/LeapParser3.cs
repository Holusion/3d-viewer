//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.18444
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using Leap;
using UnityEngine;
using AssemblyCSharp.Utils;
namespace AssemblyCSharp
{
	public class LeapParser3:BaseParser {
		private Controller controller;
		private Models models;
		private LimitedQueue<int> swipes;
		private Smoother smoother;
		private Frame previousFrame;
		private float timer;


		//private Vector previousPos;
		public LeapParser3 (Models models){
			swipes = new LimitedQueue<int>(5);
			smoother = new Smoother();
			this.models = models;
			timer = 0f;
			controller = new Controller();
			// CONFIGURE LEAP ////////////////////
			controller.EnableGesture(Gesture.GestureType.TYPESWIPE);
			controller.Config.SetFloat("Gesture.Swipe.MinLength",150f); //DEFAULT 150f in mm
			controller.Config.SetFloat("Gesture.Swipe.MinVelocity", 500f); //DEFAULT 1000f in mm/s
			controller.Config.Save();
		}
		/**
		 * return true if leap is available and parsing suceed. False otherwise.
		 * Simply a	replacement, instead of using onFrame, thus syncing with app's pace, if called in update() method.
		 * */
		public override bool update() {
			Frame frame;
			if(!controller.IsServiceConnected()){
				return false;
			}
			if(!controller.IsConnected){
				return false;
			}
			frame = controller.Frame();


			bool ret = rotation(frame);
			if( !ret ){
				ret = swipe (frame);
			}
			//previousFrame = frame;
			return ret;
		}


		private bool swipe(Frame frame){
			bool ret = false;
			GestureList gestures;

			if(timer>=0f){
				timer -= Time.deltaTime;
				ret = true; //We switched recently
			}else{

				if(previousFrame != null && previousFrame.IsValid){
					gestures = frame.Gestures(previousFrame);
				}else{
					gestures = frame.Gestures();
				}
				foreach (Gesture gesture in gestures){
					Debug.Log("gesture");
					Debug.Log(gesture.Id);
					Debug.Log(gesture.State);
					if(Array.Find((int[])swipes.ToArray(),id=> id == gesture.Id) != gesture.Id && timer <0f){ //Check each time if timer is >0
						swipes.Enqueue(gesture.Id);
						SwipeGesture sw = new SwipeGesture(gesture);
						if(Math.Abs(sw.Direction.x) > Math.Abs(sw.Direction.y)*2f ){
							timer =2f;
							models.next();
							ret = true; //We are switching
						}
					}else if(gesture.State == Gesture.GestureState.STATESTOP){
						//Gesture was already counted
						timer = 0.5f;

					}
				}
			}

			return ret;
		}

		private bool rotation(Frame frame){
			bool ret = false;
			Hand hand = frame.Hands.Frontmost;
			Model model = models.getCurrent();
			//We have at least progressed 1 frame
			if (hand.PinchStrength>=1f ||(hand.PinchStrength>0.8f && hand.GrabStrength == 1f)){
				smoother.Push(getRotation(hand));
				ret = true;
			}else if(hand.PinchStrength >0.95f){
				//Might be a pinch ... or not. So just minimize effect.
				smoother.Push(getRotation(hand),0.25f);
				ret = true;
			}else{
				smoother.Push(Vector3.zero,0.25f);
			}
			//Debug.Log(smoother.Movement);
			model.setRotation(smoother.Movement*Time.deltaTime);
			
			
			return ret;
		}		
		private Vector3 getRotation(Hand hand){
			Vector3 ret;
			if(hand.IsValid && previousFrame != null && previousFrame.Hand(hand.Id).IsValid && hand.TimeVisible >0.1f){
				float framePeriod, z;
				Vector velocity;
				framePeriod =  (float)((hand.Frame.Timestamp - previousFrame.Timestamp)/1000)/1000f;
				velocity = hand.Translation(previousFrame)*0.7f/framePeriod;
				z = hand.RotationAngle(previousFrame,Vector.Backward)*30f/framePeriod;
				if(!float.IsNaN(velocity.x)){ //TODO UGLY Hack
					ret = new Vector3(velocity.y,velocity.x,z);
				}else{
					ret = new Vector3(0,0,0);
				}
			}else{
				ret = new Vector3(0,0,0);
			}
			//this.previousPos = hand.StabilizedPalmPosition;
			this.previousFrame = hand.Frame;
			//Debug.Log(ret);

			return ret;
		}


	}
}

